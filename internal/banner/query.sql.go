// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package banner

import (
	"context"
)

const createBanner = `-- name: CreateBanner :one
INSERT INTO banners (feature_id, title, text, url, is_active)
    VALUES ($1, $2, $3, $4, $5)
RETURNING
    id
`

type CreateBannerParams struct {
	FeatureID int    `db:"feature_id" json:"feature_id"`
	Title     string `db:"title" json:"title"`
	Text      string `db:"text" json:"text"`
	Url       string `db:"url" json:"url"`
	IsActive  bool   `db:"is_active" json:"is_active"`
}

func (q *Queries) CreateBanner(ctx context.Context, arg CreateBannerParams) (int, error) {
	row := q.db.QueryRowContext(ctx, createBanner,
		arg.FeatureID,
		arg.Title,
		arg.Text,
		arg.Url,
		arg.IsActive,
	)
	var id int
	err := row.Scan(&id)
	return id, err
}

const createTag = `-- name: CreateTag :one
INSERT INTO tags (tag_id, banner_id)
    VALUES ($1, $2)
RETURNING
    tag_id
`

type CreateTagParams struct {
	TagID    int `db:"tag_id" json:"tag_id"`
	BannerID int `db:"banner_id" json:"banner_id"`
}

func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) (int, error) {
	row := q.db.QueryRowContext(ctx, createTag, arg.TagID, arg.BannerID)
	var tag_id int
	err := row.Scan(&tag_id)
	return tag_id, err
}

const deleteBannerByID = `-- name: DeleteBannerByID :one
UPDATE
    banners
SET
    is_deleted = TRUE
WHERE
    id = $1
RETURNING
    id
`

func (q *Queries) DeleteBannerByID(ctx context.Context, id int) (int, error) {
	row := q.db.QueryRowContext(ctx, deleteBannerByID, id)
	err := row.Scan(&id)
	return id, err
}

const getActiveBannerByFeatureTag = `-- name: GetActiveBannerByFeatureTag :one
SELECT
    b.id,
    b.feature_id,
    b.title,
    b.text,
    b.url,
    b.is_active,
    b.is_deleted,
    b.created_at,
    b.updated_at
FROM
    banners b
    JOIN tags t ON t.banner_id = b.id
WHERE
    b.feature_id = $1
    AND b.is_active = TRUE
    AND b.is_deleted = FALSE
    AND t.tag_id = $2
`

type GetActiveBannerByFeatureTagParams struct {
	FeatureID int `db:"feature_id" json:"feature_id"`
	TagID     int `db:"tag_id" json:"tag_id"`
}

func (q *Queries) GetActiveBannerByFeatureTag(ctx context.Context, arg GetActiveBannerByFeatureTagParams) (Banner, error) {
	row := q.db.QueryRowContext(ctx, getActiveBannerByFeatureTag, arg.FeatureID, arg.TagID)
	var i Banner
	err := row.Scan(
		&i.ID,
		&i.FeatureID,
		&i.Title,
		&i.Text,
		&i.Url,
		&i.IsActive,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBannerByID = `-- name: GetBannerByID :one
SELECT
    id, feature_id, title, text, url, is_active, is_deleted, created_at, updated_at
FROM
    banners
WHERE
    id = $1
`

func (q *Queries) GetBannerByID(ctx context.Context, id int) (Banner, error) {
	row := q.db.QueryRowContext(ctx, getBannerByID, id)
	var i Banner
	err := row.Scan(
		&i.ID,
		&i.FeatureID,
		&i.Title,
		&i.Text,
		&i.Url,
		&i.IsActive,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBannersByFeature = `-- name: GetBannersByFeature :many
SELECT
    id, feature_id, title, text, url, is_active, is_deleted, created_at, updated_at
FROM
    banners
WHERE
    feature_id = $1
`

func (q *Queries) GetBannersByFeature(ctx context.Context, featureID int) ([]Banner, error) {
	rows, err := q.db.QueryContext(ctx, getBannersByFeature, featureID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Banner
	for rows.Next() {
		var i Banner
		if err := rows.Scan(
			&i.ID,
			&i.FeatureID,
			&i.Title,
			&i.Text,
			&i.Url,
			&i.IsActive,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBannersByFeatureTag = `-- name: GetBannersByFeatureTag :many
SELECT
    b.id,
    b.feature_id,
    b.title,
    b.text,
    b.url,
    b.is_active,
    b.is_deleted,
    b.created_at,
    b.updated_at
FROM
    banners b
    JOIN tags t ON t.banner_id = b.id
WHERE
    b.feature_id = $1
    AND t.tag_id = $2
`

type GetBannersByFeatureTagParams struct {
	FeatureID int `db:"feature_id" json:"feature_id"`
	TagID     int `db:"tag_id" json:"tag_id"`
}

func (q *Queries) GetBannersByFeatureTag(ctx context.Context, arg GetBannersByFeatureTagParams) ([]Banner, error) {
	rows, err := q.db.QueryContext(ctx, getBannersByFeatureTag, arg.FeatureID, arg.TagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Banner
	for rows.Next() {
		var i Banner
		if err := rows.Scan(
			&i.ID,
			&i.FeatureID,
			&i.Title,
			&i.Text,
			&i.Url,
			&i.IsActive,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBannersByFeatureTagWithLimit = `-- name: GetBannersByFeatureTagWithLimit :many
SELECT
    b.id,
    b.feature_id,
    b.title,
    b.text,
    b.url,
    b.is_active,
    b.is_deleted,
    b.created_at,
    b.updated_at
FROM
    banners b
    JOIN tags t ON t.banner_id = b.id
WHERE
    b.feature_id = $1
    AND t.tag_id = $2
ORDER BY
    b.id
LIMIT $3
`

type GetBannersByFeatureTagWithLimitParams struct {
	FeatureID int `db:"feature_id" json:"feature_id"`
	TagID     int `db:"tag_id" json:"tag_id"`
	Limit     int `db:"limit" json:"limit"`
}

func (q *Queries) GetBannersByFeatureTagWithLimit(ctx context.Context, arg GetBannersByFeatureTagWithLimitParams) ([]Banner, error) {
	rows, err := q.db.QueryContext(ctx, getBannersByFeatureTagWithLimit, arg.FeatureID, arg.TagID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Banner
	for rows.Next() {
		var i Banner
		if err := rows.Scan(
			&i.ID,
			&i.FeatureID,
			&i.Title,
			&i.Text,
			&i.Url,
			&i.IsActive,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBannersByFeatureTagWithLimitOffset = `-- name: GetBannersByFeatureTagWithLimitOffset :many
SELECT
    b.id,
    b.feature_id,
    b.title,
    b.text,
    b.url,
    b.is_active,
    b.is_deleted,
    b.created_at,
    b.updated_at
FROM
    banners b
    JOIN tags t ON t.banner_id = b.id
WHERE
    b.feature_id = $1
    AND t.tag_id = $2
ORDER BY
    b.id
LIMIT $3 OFFSET $4
`

type GetBannersByFeatureTagWithLimitOffsetParams struct {
	FeatureID int `db:"feature_id" json:"feature_id"`
	TagID     int `db:"tag_id" json:"tag_id"`
	Limit     int `db:"limit" json:"limit"`
	Offset    int `db:"offset" json:"offset"`
}

func (q *Queries) GetBannersByFeatureTagWithLimitOffset(ctx context.Context, arg GetBannersByFeatureTagWithLimitOffsetParams) ([]Banner, error) {
	rows, err := q.db.QueryContext(ctx, getBannersByFeatureTagWithLimitOffset,
		arg.FeatureID,
		arg.TagID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Banner
	for rows.Next() {
		var i Banner
		if err := rows.Scan(
			&i.ID,
			&i.FeatureID,
			&i.Title,
			&i.Text,
			&i.Url,
			&i.IsActive,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBannersByFeatureTagWithOffset = `-- name: GetBannersByFeatureTagWithOffset :many
SELECT
    b.id,
    b.feature_id,
    b.title,
    b.text,
    b.url,
    b.is_active,
    b.is_deleted,
    b.created_at,
    b.updated_at
FROM
    banners b
    JOIN tags t ON t.banner_id = b.id
WHERE
    b.feature_id = $1
    AND t.tag_id = $2
ORDER BY
    b.id OFFSET $3
`

type GetBannersByFeatureTagWithOffsetParams struct {
	FeatureID int `db:"feature_id" json:"feature_id"`
	TagID     int `db:"tag_id" json:"tag_id"`
	Offset    int `db:"offset" json:"offset"`
}

func (q *Queries) GetBannersByFeatureTagWithOffset(ctx context.Context, arg GetBannersByFeatureTagWithOffsetParams) ([]Banner, error) {
	rows, err := q.db.QueryContext(ctx, getBannersByFeatureTagWithOffset, arg.FeatureID, arg.TagID, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Banner
	for rows.Next() {
		var i Banner
		if err := rows.Scan(
			&i.ID,
			&i.FeatureID,
			&i.Title,
			&i.Text,
			&i.Url,
			&i.IsActive,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBannersByFeatureWithLimit = `-- name: GetBannersByFeatureWithLimit :many
SELECT
    id, feature_id, title, text, url, is_active, is_deleted, created_at, updated_at
FROM
    banners
WHERE
    feature_id = $1
ORDER BY
    id
LIMIT $2
`

type GetBannersByFeatureWithLimitParams struct {
	FeatureID int `db:"feature_id" json:"feature_id"`
	Limit     int `db:"limit" json:"limit"`
}

func (q *Queries) GetBannersByFeatureWithLimit(ctx context.Context, arg GetBannersByFeatureWithLimitParams) ([]Banner, error) {
	rows, err := q.db.QueryContext(ctx, getBannersByFeatureWithLimit, arg.FeatureID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Banner
	for rows.Next() {
		var i Banner
		if err := rows.Scan(
			&i.ID,
			&i.FeatureID,
			&i.Title,
			&i.Text,
			&i.Url,
			&i.IsActive,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBannersByFeatureWithLimitOffset = `-- name: GetBannersByFeatureWithLimitOffset :many
SELECT
    id, feature_id, title, text, url, is_active, is_deleted, created_at, updated_at
FROM
    banners
WHERE
    feature_id = $1
ORDER BY
    id
LIMIT $2 OFFSET $3
`

type GetBannersByFeatureWithLimitOffsetParams struct {
	FeatureID int `db:"feature_id" json:"feature_id"`
	Limit     int `db:"limit" json:"limit"`
	Offset    int `db:"offset" json:"offset"`
}

func (q *Queries) GetBannersByFeatureWithLimitOffset(ctx context.Context, arg GetBannersByFeatureWithLimitOffsetParams) ([]Banner, error) {
	rows, err := q.db.QueryContext(ctx, getBannersByFeatureWithLimitOffset, arg.FeatureID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Banner
	for rows.Next() {
		var i Banner
		if err := rows.Scan(
			&i.ID,
			&i.FeatureID,
			&i.Title,
			&i.Text,
			&i.Url,
			&i.IsActive,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBannersByFeatureWithOffset = `-- name: GetBannersByFeatureWithOffset :many
SELECT
    id, feature_id, title, text, url, is_active, is_deleted, created_at, updated_at
FROM
    banners
WHERE
    feature_id = $1
ORDER BY
    id OFFSET $2
`

type GetBannersByFeatureWithOffsetParams struct {
	FeatureID int `db:"feature_id" json:"feature_id"`
	Offset    int `db:"offset" json:"offset"`
}

func (q *Queries) GetBannersByFeatureWithOffset(ctx context.Context, arg GetBannersByFeatureWithOffsetParams) ([]Banner, error) {
	rows, err := q.db.QueryContext(ctx, getBannersByFeatureWithOffset, arg.FeatureID, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Banner
	for rows.Next() {
		var i Banner
		if err := rows.Scan(
			&i.ID,
			&i.FeatureID,
			&i.Title,
			&i.Text,
			&i.Url,
			&i.IsActive,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBannersIDsByTag = `-- name: GetBannersIDsByTag :many
SELECT
    id, tag_id, banner_id
FROM
    tags
WHERE
    tag_id = $1
`

func (q *Queries) GetBannersIDsByTag(ctx context.Context, tagID int) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getBannersIDsByTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.TagID, &i.BannerID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBannersIDsByTagWithLimit = `-- name: GetBannersIDsByTagWithLimit :many
SELECT
    id, tag_id, banner_id
FROM
    tags
WHERE
    tag_id = $1
ORDER BY
    banner_id
LIMIT $2
`

type GetBannersIDsByTagWithLimitParams struct {
	TagID int `db:"tag_id" json:"tag_id"`
	Limit int `db:"limit" json:"limit"`
}

func (q *Queries) GetBannersIDsByTagWithLimit(ctx context.Context, arg GetBannersIDsByTagWithLimitParams) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getBannersIDsByTagWithLimit, arg.TagID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.TagID, &i.BannerID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBannersIDsByTagWithLimitOffset = `-- name: GetBannersIDsByTagWithLimitOffset :many
SELECT
    id, tag_id, banner_id
FROM
    tags
WHERE
    tag_id = $1
ORDER BY
    banner_id
LIMIT $2 OFFSET $3
`

type GetBannersIDsByTagWithLimitOffsetParams struct {
	TagID  int `db:"tag_id" json:"tag_id"`
	Limit  int `db:"limit" json:"limit"`
	Offset int `db:"offset" json:"offset"`
}

func (q *Queries) GetBannersIDsByTagWithLimitOffset(ctx context.Context, arg GetBannersIDsByTagWithLimitOffsetParams) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getBannersIDsByTagWithLimitOffset, arg.TagID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.TagID, &i.BannerID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBannersIDsByTagWithOffset = `-- name: GetBannersIDsByTagWithOffset :many
SELECT
    id, tag_id, banner_id
FROM
    tags
WHERE
    tag_id = $1
ORDER BY
    banner_id OFFSET $2
`

type GetBannersIDsByTagWithOffsetParams struct {
	TagID  int `db:"tag_id" json:"tag_id"`
	Offset int `db:"offset" json:"offset"`
}

func (q *Queries) GetBannersIDsByTagWithOffset(ctx context.Context, arg GetBannersIDsByTagWithOffsetParams) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getBannersIDsByTagWithOffset, arg.TagID, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.TagID, &i.BannerID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsByBannerID = `-- name: GetTagsByBannerID :many
SELECT
    id, tag_id, banner_id
FROM
    tags
WHERE
    banner_id = $1
`

func (q *Queries) GetTagsByBannerID(ctx context.Context, bannerID int) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getTagsByBannerID, bannerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.TagID, &i.BannerID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT
    id, name, role, created_at, updated_at
FROM
    users
WHERE
    id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id int) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateBannerByID = `-- name: UpdateBannerByID :one
UPDATE
    banners
SET
    title = $1,
    text = $2,
    url = $3
WHERE
    id = $4
RETURNING
    id
`

type UpdateBannerByIDParams struct {
	Title string `db:"title" json:"title"`
	Text  string `db:"text" json:"text"`
	Url   string `db:"url" json:"url"`
	ID    int    `db:"id" json:"id"`
}

func (q *Queries) UpdateBannerByID(ctx context.Context, arg UpdateBannerByIDParams) (int, error) {
	row := q.db.QueryRowContext(ctx, updateBannerByID,
		arg.Title,
		arg.Text,
		arg.Url,
		arg.ID,
	)
	var id int
	err := row.Scan(&id)
	return id, err
}

const updateBannerTagByID = `-- name: UpdateBannerTagByID :one
UPDATE
    tags
SET
    tag_id = $1
WHERE
    banner_id = $2
    and id = $3
RETURNING
    id
`

type UpdateBannerTagByIDParams struct {
	TagID    int `db:"tag_id" json:"tag_id"`
	BannerID int `db:"banner_id" json:"banner_id"`
	ID       int `db:"id" json:"id"`
}

func (q *Queries) UpdateBannerTagByID(ctx context.Context, arg UpdateBannerTagByIDParams) (int, error) {
	row := q.db.QueryRowContext(ctx, updateBannerTagByID, arg.TagID, arg.BannerID, arg.ID)
	var id int
	err := row.Scan(&id)
	return id, err
}

const updateFeatureByID = `-- name: UpdateFeatureByID :one
UPDATE
    banners
SET
    feature_id = $1
WHERE
    id = $2
RETURNING
    id
`

type UpdateFeatureByIDParams struct {
	FeatureID int `db:"feature_id" json:"feature_id"`
	ID        int `db:"id" json:"id"`
}

func (q *Queries) UpdateFeatureByID(ctx context.Context, arg UpdateFeatureByIDParams) (int, error) {
	row := q.db.QueryRowContext(ctx, updateFeatureByID, arg.FeatureID, arg.ID)
	var id int
	err := row.Scan(&id)
	return id, err
}

const updateIsActiveByID = `-- name: UpdateIsActiveByID :one
UPDATE
    banners
SET
    is_active = $1
WHERE
    id = $2
RETURNING
    id
`

type UpdateIsActiveByIDParams struct {
	IsActive bool `db:"is_active" json:"is_active"`
	ID       int  `db:"id" json:"id"`
}

func (q *Queries) UpdateIsActiveByID(ctx context.Context, arg UpdateIsActiveByIDParams) (int, error) {
	row := q.db.QueryRowContext(ctx, updateIsActiveByID, arg.IsActive, arg.ID)
	var id int
	err := row.Scan(&id)
	return id, err
}
